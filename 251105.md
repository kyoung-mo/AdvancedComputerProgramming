# 19번

```c

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define  FACTOR_ONEUNDER_ERROR    -100

int Factorial(int);

int main(void)
{
    int n, result;

    fputs("숫자 입력(1이상): ", stdout);
    scanf("%d", &n);

    if (n < 1) {
		printf("경고: 1 이상의 숫자를 입력하세요.\n\n");
    }
    
    result = Factorial(n);
    printf("%d! = %d\n", n, result);

    //문제 상황 발생 시 경고문 출력 코드 작성

    return 0;
}

int Factorial(int num)
{
    int fact = 0;

    if (num >= 1) {
        fact = 1;
        for (int i = 1; i <= num; i++) {
            fact *= i;
        }
    }
    else {
        fact = FACTOR_ONEUNDER_ERROR;
	}

    return fact;
}

```
---

# 20번

```c


#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define  DIVIDE_BY_ZERO    -256

int DivInt(int, int, int*);

int main(void)
{
    int dd, ds;
    int result[2];

    while (1)
    {
        fputs("나눗셈 위한 두 정수 입력: ", stdout);
        scanf("%d %d", &dd, &ds);


        //함수에 입력하고 조건에 따라 결과 값 또는 경고문 출력
        int i;
        
        i = DivInt(dd, ds, result);
        
        if (i == DIVIDE_BY_ZERO) {
            printf("0으로 나누는 오류 발생! 숫자 재입력 \n");
            continue;
        }
        else {
            printf("몫 : %d, 나머지 : %d \n",result[0],result[1]);
        }
    }
    return 0;
}

int DivInt(int divid, int divisor, int* resultArr)
{
    // 0이 입력 되었을 때 출력 값
    if (divisor == 0) {
        return DIVIDE_BY_ZERO;
    }

    // 0이 아닐 때 계산 결과 값 출력
    else {
        resultArr[0] = divid / divisor;
        resultArr[1] = divid % divisor;
        //printf("몫: % d, 나머지 : % d \n",resultArr[0], resultArr[1]);
    }

    return 1;
}
```
---

# 21번

```c

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int SumOfArray(int* arrPtr, int arrLen)
{
    // 합 계산 코드 작성
    int total = 0;
    for (int i = 0; i < arrLen; i++)
        total += arrPtr[i];

    return total;
}

int main(void)
{
    int arr1[3] = { 5, 10, 15 };
    int arr2[5] = { 1, 2, 3, 4, 5 };

    int sumOfArrResult = 0;

    // 함수를 이용하여 arr1 합 계산 작성, output value는 sumOfArrResult
    sumOfArrResult = SumOfArray(arr1, sizeof(arr1)/4);
    printf("5, 10, 15의 합: %d \n", sumOfArrResult);

    // 함수를 이용하여 arr2 합 계산 작성 output value는 sumOfArrResult
    sumOfArrResult = SumOfArray(arr2, sizeof(arr2)/4);
    printf("1, 2, 3, 4, 5의 합: %d \n", sumOfArrResult);
    return 0;
}





```
---

# 22번
##### scanf(" %s",&ch) > 따옴표 안에 띄어쓰기 한번 하고 %s?

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#define   STR_MAX      100

int CharNumOfString(char* str, char ch)
{
    // 문자열 안에 알고자 하는 문자가 몇개 들어있는지 count 하는 코드 작성
    int chCnt=0;

    for (int i = 0; i < strlen(str); i++) {
        if (str[i]==ch)
            chCnt += 1;
    }

    return chCnt;
}

int main(void)
{
    char str[STR_MAX];
    char ch;
    int chCnt;

    fputs("대상 문자열 입력: ", stdout);
    // 문자열 입력 함수 작성
    fgets(str, STR_MAX, stdin);

    fputs("세어 볼 문자 입력: ", stdout);
    // 문자 입력 함수 작성
    scanf(" %c", &ch);

    // CharNumOfString 함수 입력 작성 결과 값은 chCnt에 저장
    chCnt = CharNumOfString(str, ch);
    printf("%c의 개수: %d \n", ch, chCnt);
    return 0;
}
```
---

<img width="903" height="193" alt="image" src="https://github.com/user-attachments/assets/fbfba113-c8a6-435a-8f9d-f57d6a3c4239" />

# 25-1번

```c

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void)
{
    char ch;
    int iNum;
    double dNum;
    char str[100];

    printf("[문자, 정수, 실수, 문자열]의 포맷으로 입력: ");
    scanf("%c, %d, %lf, %s", &ch, &iNum, &dNum, str);

    printf("\n입력된 데이터 출력: ");
    printf("ch = %c, iNum = %d, dNum = %lf, str = %s", ch, iNum, dNum, str);

    return 0;
}

```
---

# 25-2번

```c

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void)
{
    char ch;
    int iNum;
    double dNum;
    char str[100];

    printf("[문자, 정수, 실수, 문자열]의 포맷으로 입력: ");
    scanf("%c, %d, %lf, %s", &ch, &iNum, &dNum, str);

    printf("\n입력된 데이터 출력: ");
    printf("ch = %c, iNum = %d, dNum = %lf, str = %s", ch, iNum, dNum, str);

    return 0;
}

```
---

# 26-1번

```c

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define  EXT_SIZE   5

int ExtendMemForString(char** pStr, int strLen);

int main(void)
{
    int strLen = 5;
    char* str = (char*)malloc(sizeof(char) * strLen);

    strcpy(str, "Best");
    puts(str);

    strLen = ExtendMemForString(&str, strLen);
    printf("확장된 문자열 길이: %d \n", strLen);
    strcat(str, " guy!");
    puts(str);

    return 0;
}


/* 함    수: int ExtendMemForString(char ** pStr, int strLen)
 * 기    능: 문자열 저장을 위해 메모리 공간을 확장.
 *
 * 반    환
 *     확장된 길이. 오류 발생시 -1 반환.
 *     첫 번째 매개변수를 통해 새로 할당된 메모리 공간 반환.
 *
 * 특이사항
 *     문자열을 위해 힙에 메모리 공간을 할당한다. 따라서 반드시
 *     따라서 반드시 반환되는 포인터를 대상으로 free 함수를 호출해야 함.
 */
int ExtendMemForString(char** pStr, int strLen)
{
    int i;
    char* newStrPtr;

    newStrPtr = (char*)malloc(sizeof(char) * (strLen + EXT_SIZE));
    if (newStrPtr == NULL)
        return -1;

    for (i = 0; i < strLen; i++)
        newStrPtr[i] = (*pStr)[i];

    free(*pStr);
    *pStr = newStrPtr;
    return strLen + EXT_SIZE;
}


```
---

# 26-2번

```c

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void)
{
    char ch;
    int iNum;
    double dNum;
    char str[100];

    printf("[문자, 정수, 실수, 문자열]의 포맷으로 입력: ");
    scanf("%c, %d, %lf, %s", &ch, &iNum, &dNum, str);

    printf("\n입력된 데이터 출력: ");
    printf("ch = %c, iNum = %d, dNum = %lf, str = %s", ch, iNum, dNum, str);

    return 0;
}

```
---

# 26-3번

```c

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define  STR_NUM    5
#define  EXT_SIZE   5

int ExtendMemForString(char** pStr, int strLen);
char* ReadString(void);
void SortString(char* strArr[STR_NUM]);

int main(void)
{
    char* strArr[STR_NUM];
    int i;

    for (i = 0; i < STR_NUM; i++)
    {
        printf("문자열 입력 %d: ", i + 1);
        strArr[i] = ReadString();
    }

    SortString(strArr);

    /** 정렬된 문자열 출력 **/
    for (i = 0; i < STR_NUM; i++)
        puts(strArr[i]);

    /** 문자열을 위한 메모리 공간 반환 **/
    for (i = 0; i < STR_NUM; i++)
        free(strArr[i]);

    return 0;
}

int ExtendMemForString(char** pStr, int strLen)
{
    int i;
    char* newStrPtr;

    newStrPtr = (char*)malloc(sizeof(char) * (strLen + EXT_SIZE));
    if (newStrPtr == NULL)
        return -1;

    for (i = 0; i < strLen; i++)
        newStrPtr[i] = (*pStr)[i];

    free(*pStr);
    *pStr = newStrPtr;
    return strLen + EXT_SIZE;
}

char* ReadString()
{
    int maxStrLen = 10;
    char* str = (char*)malloc(sizeof(char) * maxStrLen);
    int idx = 0;

    while (1)
    {
        if (idx >= maxStrLen)
            maxStrLen = ExtendMemForString(&str, maxStrLen);

        str[idx] = getchar();
        if (str[idx] == '\n')
        {
            str[idx] = 0;
            break;
        }
        idx++;
    }

    return str;
}

void SortString(char* strArr[STR_NUM])
{
    int i, j;
    char* tempStr;

    /** 문자열 정렬과정(버블정렬방식)  **/
    for (i = 0; i < STR_NUM - 1; i++)
    {
        for (j = 0; j < (STR_NUM - i) - 1; j++)
        {
            // 버블 정렬 방식 이용하여 작성
            if (strlen(strArr[j]) > strlen(strArr[j + 1]))
            {
                tempStr = strArr[j];
                strArr[j] = strArr[j + 1];
                strArr[j + 1] = tempStr;
            }
        }
    }
}


```
---

# 29번? - 오류

```c

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#define  STR_LEN    50
#define  BOOK_INFO_NUM   3

typedef struct bookInfo {
    char bookTitle[STR_LEN];
    char bookPub[STR_LEN];
    int bookPrice;
}bookInfo;

bookInfo bookInfoList[BOOK_INFO_NUM];

int main(void)
{
    int i, num;
    bookInfo book;

    puts("********* 도서 정보 입력 *********");
    for (i = 0; i < BOOK_INFO_NUM; i++)
    {
        printf("%d 번째 도서 정보 입력. \n", (i + 1));

        fputs("도서 제목: ", stdout);
        gets(book.bookTitle);

        fputs("출판사 명: ", stdout);
        gets(book.bookPub);

        fputs("도서 가격: ", stdout);
        gets(book.bookPrice);
        fflush(stdin);

        num = InsertList(&book);
        if (num == 1)
            printf("입력에 실패하였습니다. \n");
        else
            printf("%d 번째 입력 완료......\n\n", num);

    }

    puts("********* 도서 정보 출력 *********");
    for (i = 0; i < BOOK_INFO_NUM; i++)
    {
        printf("%d 번째 도서 정보 출력. \n", (i + 1));
        printf("도서 제목: %s \n", bookInfoList[i].bookTitle);
        printf("출판사 명: %s \n", bookInfoList[i].bookPub);
        printf("도서 가격: %s \n", bookInfoList[i].bookPrice);
    }

    return 0;
}

```
---

# 30번

```c

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#define  STR_LEN    50
#define  BOOK_INFO_NUM   3

typedef struct bookInfo {
    char bookTitle[STR_LEN];
    char bookPub[STR_LEN];
    int bookPrice;
}bookInfo;

int numOfData = 0;
bookInfo bookInfoList[BOOK_INFO_NUM];

/** 정렬을 위한 상수 정의 **/
enum { SORT_TITLE = 1, SORT_PUB, SORT_PRICE, EXIT };
bookInfo* bookSortList[BOOK_INFO_NUM];

int InsertList(bookInfo* bookPtr);

void InitSortList(void);
void PrintSortList(void);

void SortByTitle(void);
void SortByPubName(void);
void SortByPrice(void);

int main(void)
{
    int i, num;
    int choice;
    bookInfo book;

    puts("********* 도서 정보 입력 *********");
    for (i = 0; i < BOOK_INFO_NUM; i++)
    {
        printf("%d번째 도서 정보 입력. \n", (i + 1));

        fputs("도서 제목: ", stdout);
        gets(book.bookTitle);

        fputs("출판사 명: ", stdout);
        gets(book.bookPub);

        fputs("도서 가격: ", stdout);
        scanf("%d", &(book.bookPrice));
        while (getchar() != '\n') continue;

        num = InsertList(&book);
        if (num == -1)
            printf("입력에 실패하였습니다. \n");
        else
            printf("%d번째 입력 완료.......\n\n", num);
    }

    InitSortList();
    while (1)
    {
        puts("********* 도서 정보 출력 *********");
        puts("정렬방식 선택...... ");
        puts("1.도서 제목 순, 2.출판사 순, 3.가격 순, 4.종료 ");
        fputs("그대의 선택은? ", stdout);
        scanf("%d", &choice);
        if (choice == EXIT)
            break;

        switch (choice)
        {
        case SORT_TITLE:
            SortByTitle();
            PrintSortList();
            break;

        case SORT_PUB:
            SortByPubName();
            PrintSortList();
            break;

        case SORT_PRICE:
            SortByPrice();
            PrintSortList();
            break;
        }
    }

    return 0;
}

int InsertList(bookInfo* bookPtr)
{
    int idx;
    int inputIdx = numOfData;

    if (numOfData >= BOOK_INFO_NUM)
        return -1; // -1은 입력 실패를 의미

    /** 입력 위치 찾기 **/
    for (idx = 0; idx < numOfData; idx++)
    {
        if (strcmp(bookInfoList[idx].bookTitle, bookPtr->bookTitle) > 0)
        {
            inputIdx = idx;
            break;
        }
    }

    /** 입력이 가능하도록 자리를 마련 **/
    for (idx = numOfData; idx > inputIdx; idx--)
        bookInfoList[idx] = bookInfoList[idx - 1];

    /** 새로운 데이터 입력 **/
    bookInfoList[inputIdx] = (*bookPtr);

    /** 입력 성공 시 입력된 데이터 개수 반환 **/
    return ++numOfData;
}

void InitSortList(void)
{
    int i;
    for (i = 0; i < BOOK_INFO_NUM; i++)
        bookSortList[i] = &bookInfoList[i];
}

void PrintSortList(void)
{
    int i;
    for (i = 0; i < BOOK_INFO_NUM; i++)
    {
        printf("%d번째 도서 정보 출력. \n", (i + 1));
        printf("도서 제목: %s \n", bookSortList[i]->bookTitle);
        printf("출판사 명: %s \n", bookSortList[i]->bookPub);
        printf("도서 가격: %d \n\n", bookSortList[i]->bookPrice);
    }
}

void SortByTitle(void)
{
    InitSortList();
}


void SortByPubName(void)
{
    int i, j;
    bookInfo* temp;

    for (i = 0; i < BOOK_INFO_NUM - 1; i++)
    {
        for (j = 0; j < (BOOK_INFO_NUM - i) - 1; j++)
        {
            if (strcmp(bookSortList[j]->bookPub, bookSortList[j + 1]->bookPub) > 0)
            {
                temp = bookSortList[j];
                bookSortList[j] = bookSortList[j + 1];
                bookSortList[j + 1] = temp;
            }
        }
    }
}

void SortByPrice(void)
{
    int i, j;
    bookInfo* temp;

    for (i = 0; i < BOOK_INFO_NUM - 1; i++)
    {
        for (j = 0; j < (BOOK_INFO_NUM - i) - 1; j++)
        {
            if (bookSortList[j]->bookPrice > bookSortList[j + 1]->bookPrice)
            {
                temp = bookSortList[j];
                bookSortList[j] = bookSortList[j + 1];
                bookSortList[j + 1] = temp;
            }
        }
    }
}


```

---

# 30번 - 추가 문제

```c

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#define  STR_LEN    50
#define  BOOK_INFO_NUM   4

typedef struct bookInfo {
    char bookTitle[STR_LEN];
    char bookPub[STR_LEN];
    int bookPrice;
    int bookYear;
}bookInfo;

int numOfData = 0;
bookInfo bookInfoList[BOOK_INFO_NUM];

/** 정렬을 위한 상수 정의 **/
enum { SORT_TITLE = 1, SORT_PUB, SORT_PRICE, SORT_YEAR, EXIT };
bookInfo* bookSortList[BOOK_INFO_NUM];

int InsertList(bookInfo* bookPtr);

void InitSortList(void);
void PrintSortList(void);

void SortByTitle(void);
void SortByPubName(void);
void SortByPrice(void);
void SortByYear(void);

int main(void)
{
    int i, num;
    int choice;
    bookInfo book;

    puts("********* 도서 정보 입력 *********");
    for (i = 0; i < BOOK_INFO_NUM; i++)
    {
        printf("%d번째 도서 정보 입력. \n", (i + 1));

        fputs("도서 제목: ", stdout);
        gets(book.bookTitle);

        fputs("출판사 명: ", stdout);
        gets(book.bookPub);

        fputs("도서 가격: ", stdout);
        scanf("%d", &(book.bookPrice));

        fputs("발행 년도: ", stdout);
        scanf("%d", &(book.bookYear));
        while (getchar() != '\n') continue;

        num = InsertList(&book);
        if (num == -1)
            printf("입력에 실패하였습니다. \n");
        else
            printf("%d번째 입력 완료.......\n\n", num);
    }

    InitSortList();
    while (1)
    {
        puts("********* 도서 정보 출력 *********");
        puts("정렬방식 선택...... ");
        puts("1.도서 제목 순, 2.출판사 순, 3.가격 순, 4.발행 년도 5.종료 ");
        fputs("그대의 선택은? ", stdout);
        scanf("%d", &choice);
        if (choice == EXIT)
            break;

        switch (choice)
        {
        case SORT_TITLE:
            SortByTitle();
            PrintSortList();
            break;

        case SORT_PUB:
            SortByPubName();
            PrintSortList();
            break;

        case SORT_PRICE:
            SortByPrice();
            PrintSortList();
            break;

        case SORT_YEAR:
            SortByYear();
            PrintSortList();
            break;
        }
    }

    return 0;
}

int InsertList(bookInfo* bookPtr)
{
    int idx;
    int inputIdx = numOfData;

    if (numOfData >= BOOK_INFO_NUM)
        return -1; // -1은 입력 실패를 의미

    /** 입력 위치 찾기 **/
    for (idx = 0; idx < numOfData; idx++)
    {
        if (strcmp(bookInfoList[idx].bookTitle, bookPtr->bookTitle) > 0)
        {
            inputIdx = idx;
            break;
        }
    }

    /** 입력이 가능하도록 자리를 마련 **/
    for (idx = numOfData; idx > inputIdx; idx--)
        bookInfoList[idx] = bookInfoList[idx - 1];

    /** 새로운 데이터 입력 **/
    bookInfoList[inputIdx] = (*bookPtr);

    /** 입력 성공 시 입력된 데이터 개수 반환 **/
    return ++numOfData;
}

void InitSortList(void)
{
    int i;
    for (i = 0; i < BOOK_INFO_NUM; i++)
        bookSortList[i] = &bookInfoList[i];
}

void PrintSortList(void)
{
    int i;
    for (i = 0; i < BOOK_INFO_NUM; i++)
    {
        printf("%d번째 도서 정보 출력. \n", (i + 1));
        printf("도서 제목: %s \n", bookSortList[i]->bookTitle);
        printf("출판사 명: %s \n", bookSortList[i]->bookPub);
        printf("도서 가격: %d \n", bookSortList[i]->bookPrice);
        printf("발행 년도: %d \n\n", bookSortList[i]->bookYear);
    }
}

void SortByTitle(void)
{
    InitSortList();
}


void SortByPubName(void)
{
    int i, j;
    bookInfo* temp;

    for (i = 0; i < BOOK_INFO_NUM - 1; i++)
    {
        for (j = 0; j < (BOOK_INFO_NUM - i) - 1; j++)
        {
            if (strcmp(bookSortList[j]->bookPub, bookSortList[j + 1]->bookPub) > 0)
            {
                temp = bookSortList[j];
                bookSortList[j] = bookSortList[j + 1];
                bookSortList[j + 1] = temp;
            }
        }
    }
}

void SortByPrice(void)
{
    int i, j;
    bookInfo* temp;

    for (i = 0; i < BOOK_INFO_NUM - 1; i++)
    {
        for (j = 0; j < (BOOK_INFO_NUM - i) - 1; j++)
        {
            if (bookSortList[j]->bookPrice > bookSortList[j + 1]->bookPrice)
            {
                temp = bookSortList[j];
                bookSortList[j] = bookSortList[j + 1];
                bookSortList[j + 1] = temp;
            }
        }
    }
}

void SortByYear(void)
{
    int i, j;
    bookInfo* temp;

    for (i = 0; i < BOOK_INFO_NUM - 1; i++)
    {
        for (j = 0; j < (BOOK_INFO_NUM - i) - 1; j++)
        {
            if (bookSortList[j]->bookYear > bookSortList[j + 1]->bookYear)
            {
                temp = bookSortList[j];
                bookSortList[j] = bookSortList[j + 1];
                bookSortList[j + 1] = temp;
            }
        }
    }
}



```
